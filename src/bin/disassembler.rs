use std::{fs, process::exit};

use clap::Parser;

use ccil::{constants::{BYTECODE_HEADER_SIZE, CCIL_MAGIC_BYTE_0, CCIL_MAGIC_BYTE_1}, vm::{chunk::Chunk, opcode::OpCodeLookup}};


/// ccil bytecode disassembler
#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    /// Path of ccil assembly file
    input_path: String,

    /// Output file
    #[arg(short, long, default_value_t = String::new())]
    output_path: String
}

fn main() {
    let opcode_lookup = OpCodeLookup::new();

    let args = Args::parse();
    
    let input_file = match fs::read(args.input_path) {
        Ok(val) => val,
        Err(error) => {
            eprintln!("Failed to read input file: {}", error);
            exit(1);
        }
    };

    // verify header; refer to bottom assembler.rs for more info
    if input_file.len() < 16 || input_file[0] != CCIL_MAGIC_BYTE_0 || input_file[1] != CCIL_MAGIC_BYTE_1 {
        eprintln!("Header mismatch; file could not be verified as ccil bytecode");
        exit(1);
    }
    let (_version_major, _version_minor, _version_patch) = (input_file[2], input_file[3], input_file[4]); // for future use

    let chunk = input_file[BYTECODE_HEADER_SIZE..].to_vec();
    let mut offset = 0;
    let mut assembly = "// CCIL BYTECODE ASSEMBLY AUTO-GENERATED BY DISASSEMBLER\n\n".to_string();

    while offset < chunk.len() {
        let opcode_byte = chunk[offset];
        let opcode = match opcode_lookup.from_byte(opcode_byte) {
            Some(val) => val,
            None => {
                eprintln!("Error at offset {}: {:02x} does not match with a valid opcode", offset, opcode_byte);
                exit(1);
            }
        };
        offset += 1;

        assembly += opcode.symbol;

        for _ in 0..opcode.num_params {
            let arg = chunk.read_arg(offset);
            assembly.push_str(&format!(" {}", arg));
            offset += 4;
        }

        assembly += "\n";
    }

    if args.output_path.is_empty() {
        print!("{}", assembly)
    } else {
        match fs::write(args.output_path, assembly) {
            Ok(_) => {},
            Err(error) => {
                eprintln!("Failed to write to output file: {}", error);
                exit(1);
            }
        };
    }
    exit(0);
}
