/*
bin/disassembler.rs: The CCIL disassembler
Copyright (C) 2025-26 The CCIL Developers

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

use std::{fs, process::exit};

use chrono::{TimeZone, Utc};
use clap::Parser;

use ccil::{constants::DISASSEMBLER_METADATA_BORDER_LINE, vm::{chunk::Chunk, opcode::OpCodeLookup}};


/// ccil bytecode disassembler
#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    /// Path of ccil assembly file
    input_path: String,

    /// Output file
    #[arg(short, long, default_value_t = String::new())]
    output_path: String
}

fn main() {
    let opcode_lookup = OpCodeLookup::new();

    let args = Args::parse();
    
    let input_file = match fs::read(&args.input_path) {
        Ok(val) => val,
        Err(error) => {
            eprintln!("Failed to read input file: {}", error);
            exit(1);
        }
    };

    // verify header
    if !input_file.verify_possible_header() {
        eprintln!("Header mismatch; file could not be verified as ccil bytecode");
        exit(1);
    }
    // extract some metadata
    let (header_version_major, header_version_minor, header_version_patch) = (input_file[2], input_file[3], input_file[4]);
    let (program_version_major, program_version_minor, program_version_patch) = ccil::version();
    let flags = input_file[5];
    let bytecode_from_assembly = flags & 0x1 == 1; // 1 if bytecode was assembled, 0 if compiled from source
    let date_unix = input_file[6] as i64
                    | (input_file[7] as i64) << 8
                    | (input_file[8] as i64) << 16
                    | (input_file[9] as i64) << 24;
    let date = Utc.timestamp_opt(date_unix, 0).unwrap();

    // version check + warning
    if header_version_major != program_version_major || header_version_minor != program_version_minor {
        eprintln!(
            "Warning: Major/Minor Version mismatch between original compiler/assembler and current disassembler! \
            Accuracy not guaranteed!"
        );
    }

    let chunk = input_file.without_header();
    let mut assembly = String::new();

    // first we write some metadata
    assembly += DISASSEMBLER_METADATA_BORDER_LINE;
    assembly += "// CCIL BYTECODE ASSEMBLY AUTO-GENERATED BY DISASSEMBLER\n";
    assembly += &format!("// ORIGINAL FILENAME: {}\n", &args.input_path.split('/').last().unwrap());
    if bytecode_from_assembly {
        assembly += "// BYTECODE GENERATED FROM: ASSEMBLY\n"
    } else {
        assembly += "// BYTECODE GENERATED FROM: SOURCE FILE\n"
    }
    assembly += &format!("// CREATION TIMESTAMP: {}\n", date.format("%Y-%m-%d %H:%M:%S"));
    assembly += &format!(
        "// ORIGINALLY CREATED BY CCIL VER: {}.{}.{}\n",
        header_version_major,
        header_version_minor,
        header_version_patch
    );
    assembly += &format!(
        "// DISASSEMBLED BY CCIL VER: {}.{}.{}\n",
        program_version_major,
        program_version_minor,
        program_version_patch
    );
    assembly += DISASSEMBLER_METADATA_BORDER_LINE;
    assembly += "\n";

    let mut offset = 0;
    while offset < chunk.len() {
        let opcode_byte = chunk[offset];
        let opcode = match opcode_lookup.from_byte(opcode_byte) {
            Some(val) => val,
            None => {
                eprintln!("Error at offset {}: 0x{:02x} does not match with a valid opcode", offset, opcode_byte);
                exit(1);
            }
        };
        offset += 1;

        assembly += opcode.symbol;

        for _ in 0..opcode.num_params {
            let arg = chunk.read_arg(offset);
            assembly.push_str(&format!(" {}", arg));
            offset += 4;
        }

        assembly += "\n";
    }

    if args.output_path.is_empty() {
        print!("{}", assembly)
    } else {
        match fs::write(args.output_path, assembly) {
            Ok(_) => {},
            Err(error) => {
                eprintln!("Failed to write to output file: {}", error);
                exit(1);
            }
        };
    }
    exit(0);
}
